---
title: "Round2"
author: "Jonathan Rosenblatt"
date: "8/2/2017"
output: html_document
---



```{r preliminaries}
source('Gilron Effect of Cross Validatino.R')

balance <- TRUE   # set for TRUE for balanced folding ana refolding.
balance.log <- 'balance_log.txt'
file.remove(balance.log)
file.create(balance.log)

n.replications <- 2e2 # 4e3
p <- 5 #23
n <- 4e2 # total sample size-> n/2 in each group.
n.permutations <- 3e1 # 3e2
n.folds <- 4
cost.1 <- 1e1
cost.2 <- 1e-1
effects <- sqrt(40/400) * seq(0, 0.5, length=3) # change in locatinon
# effects <- seq(1, 1.2, length=3) # change in scale
# RNGkind("Wich") # Set random number generator. 
RNGkind("default")

Sigma <- diag(p)
# Sigma <- ar1_cov(p, rho=0.8)
# Sigma <- comSym_cov(p, rho=0.7) 
# Sigma <- diag((1:p)*p/sum(1:p))

the.message <- paste("n=",n, sep='')

file.name <- "1"
```


## Fixed folds. Cross-Validated. All in one.
```{r independent noise variable folds}
registerDoMC(cores=80)

# Many statistics are not compute for efficiency. 
# To compute them, just uncomment them.

pvals.1.9 <- foreach(j=1:n.replications, .combine=rbind)  %:% 
  foreach(effect=effects, .combine=rbind)  %dopar% {
  # effect <- effects[2]
  
  labels <- sample(c(rep(TRUE, n/2), rep(FALSE,n/2))) # group assignemt labels
  
  # Gaussian noise
  .noise <- rmvnorm(n=n, sigma = Sigma)
  # t noise
  # .noise <- rmvt(n=n, sigma = Sigma, df=3) 
  
  # Shift alternative:
  noise <- .noise + effect * labels
  
  # Scale alternative:
  # noise <- .noise * effect ^ labels 
  # plot(noise, col=labels+1, cex=1); abline(h=0,v=0, lty=2)
  
  # Golland's mixture null:
  # .noise <- rmvnorm(n=n, sigma = Sigma) # Gaussian noise
  # shift <- rep(sqrt(9/p), p)
  # shift.group <- 2*rbinom(n, 1, (0.5-effect)^labels*(0.5+effect)^(1-labels))-1
  # noise <- .noise + t(outer(shift, shift.group))
  # plot(noise, col=labels+1, cex=1); abline(h=0,v=0, lty=2)

  # Compute observed statistic
  x1 <- noise[labels,]
  x2 <- noise[!labels,]
  
  # Asign observations to folds. Use the simple label structure to balance folds.
  fold.ids <- balanced_folding(labels, n.folds, balance = balance)
  # capture.output(table(fold.ids, labels), file=balance.log, append = TRUE)
 
  # Observables 
  ts <- list(
    Oracle=t_Oracle(x1, x2, Sigma, Sigma),
    Hotelling=t_Hotelling(x1, x2, FALSE),
    Hotelling.shrink=t_Hotelling(x1, x2, TRUE),
    lda.CV.1=t_lda_cv(noise, labels, labels, fold.ids, type=1),
    lda.CV.2=t_lda_cv(noise, labels, labels, fold.ids, type=2),
    lda.noCV.1=t_lda(noise, labels, noise, labels, type=1),
    lda.noCV.2=t_lda(noise, labels, noise, labels, type=2),
    sd=t_SD(x1, x2),
    svm.CV.1=t_svm_cv(noise, labels, labels, fold.ids, cost=cost.1, type=1),
    svm.CV.2=t_svm_cv(noise, labels, labels, fold.ids, cost=cost.2, type=1),
    svm.CV.3=t_svm_cv(noise, labels, labels, fold.ids, cost=cost.1, type=2),
    svm.CV.4=t_svm_cv(noise, labels, labels, fold.ids, cost=cost.2, type=2),
    svm.noCV.1=t_svm(noise, labels, noise, labels, cost=cost.1, type=1),
    svm.noCV.2=t_svm(noise, labels, noise, labels, cost=cost.2, type=1),
    svm.noCV.3=t_svm(noise, labels, noise, labels, cost=cost.1, type=2),
    svm.noCV.4=t_svm(noise, labels, noise, labels, cost=cost.2, type=2)
  )
  
  
  # Prepare to permute
  old.labels <- labels
  old.folds.ids <- fold.ids
  statistics.names <- names(ts)
  
  # Initialize permuted statistics
  permuted <- matrix(-1, ncol=length(ts), nrow=n.permutations)
  
  for(i in 1:n.permutations){
    # i <- 1
    
    labels <- sample(labels) # make permutation
    fold.ids <- balanced_folding(labels, n.folds, balance) # refold
    x1 <- noise[labels,]
    x2 <- noise[!labels,]
    
    # Checking balance:
    # capture.output(table(.fold.ids, .labels), file=balanc.log, append = TRUE)
    
    # for permuting Xs:
    # .indexes <- sample(seq(n))
    #  .noise <- noise[.indexes,] 
    
    permuted[i,] <- c(
      Oracle=t_Oracle(x1, x2, Sigma, Sigma),
      Hotelling=t_Hotelling(x1, x2, FALSE),
      Hotelling.shrink=t_Hotelling(x1, x2, TRUE),
      lda.CV.1=t_lda_cv(noise, labels, labels, fold.ids, type=1),
      lda.CV.2=t_lda_cv(noise, labels, labels, fold.ids, type=2),
      lda.noCV.1=t_lda(noise, labels, noise, labels, type=1),
      lda.noCV.2=t_lda(noise, labels, noise, labels, type=2),
      sd=t_SD(x1, x2),
      svm.CV.1=t_svm_cv(noise, labels, labels, fold.ids, cost=cost.1, type=1),
      svm.CV.2=t_svm_cv(noise, labels, labels, fold.ids, cost=cost.2, type=1),
      svm.CV.3=t_svm_cv(noise, labels, labels, fold.ids, cost=cost.1, type=2),
      svm.CV.4=t_svm_cv(noise, labels, labels, fold.ids, cost=cost.2, type=2),
      svm.noCV.1=t_svm(noise, labels, noise, labels, cost=cost.1, type=1),
      svm.noCV.2=t_svm(noise, labels, noise, labels, cost=cost.2, type=1),
      svm.noCV.3=t_svm(noise, labels, noise, labels, cost=cost.1, type=2),
      svm.noCV.4=t_svm(noise, labels, noise, labels, cost=cost.2, type=2)
    )
  } # End permutation
  
  # Compute p-vals for each statistic
  pvals <- rep(NA, length(ts))
  for(i in seq_along(ts)){
    pvals[i] <- mean(ts[i]<=permuted[,i], na.rm=TRUE)
  }
  
  c(effect=effect, pvals) 
}
pbPost("note", "Done", the.message)
# save.image(file=file.name)
```



```{r analyze multiple effects}
err.bar <- round(3*sqrt(.05*.95/(n.replications)),3) # confidence limits of p-value
.limits <- 0.05 + c(-err.bar,0,err.bar)

pvals.1.9 %<>%  as.data.table()

names(pvals.1.9)[-1] <- c('Oracle','Hotelling','Hotelling.shrink', 'LDA.CV.1', 'LDA.CV.2', 'LDA.noCV.1', 'LDA.noCV.2',  'SD','SVM.CV.1', 'SVM.CV.2', 'SVM.CV.3',  'SVM.CV.4','SVM.noCV.1', 'SVM.noCV.2', 'SVM.noCV.3','SVM.noCV.4')
  
pvals.melt <- melt(pvals.1.9, id.vars=c("effect"), variable.name='statistic') 

pvals.melt[,c("reject","effect.factor"):=list(as.numeric(value <= 0.05), as.factor(effect)),] 
```


```{r}
plot.3 <- pvals.melt %>% 
  ggplot(aes(y=reject, x=statistic, group=effect.factor, shape=effect.factor, color=effect.factor)) +
  theme_bw(base_size = 20)+
  theme(legend.position="none")+
  # ggtitle("Fixed signal, Gaussian Noise")+
  ylab('Power')+
  xlab('')+
  stat_summary(fun.y='mean', geom="point", cex=4) +
  geom_hline(yintercept=0.05, lty=2)+
  geom_vline(xintercept=.limits, lty=c(3,2,3))+
  coord_flip()
plot.3

# pdf(file = paste('Output/',file.name,'.pdf', sep=''))
# plot.3
# dev.off()
```



```{r analyze single effect}
the.title <- sprintf('permutations=%d, replications=%d, n=%d, p=%d, n.folds=%d, errror bar=%s, balance=%s', n.permutations, n.replications, n, p, n.folds, err.bar, balance)

pvals.1.9.1 <- filter(pvals.1.9, effect==0) %>% select(-effect)
powers <- cbind(round(apply(pvals.1.9.1, 2, function(x) mean(x<=0.05, na.rm=TRUE)),3))
powers


.limits <- 0.05 + c(-err.bar,0,err.bar)
# dotchart(powers[,1]); abline(v=.limits, lty=c(3,2,3))
dotchart(powers[,1], xlim=c(0,0.1)); abline(v=.limits, lty=c(3,2,3));title(the.title)
# dotchart(powers[,1], xlim=c(0.04,0.1)); abline(v=.limits, lty=c(3,2,3)) #;title(the.title)

# pdf(file = paste('Output/',file.name,'zoom.pdf', sep=''))
# dotchart(powers[,1], xlim=c(0,0.1)); abline(v=.limits, lty=c(3,2,3))
# dev.off()
```
