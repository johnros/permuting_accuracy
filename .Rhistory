cost.2 <- 1e-1
source('Gilron Effect of Cross Validatino.R')
## Signal in location
effects <- seq(0, 0.5, length=3)
## Dependence
Sigma <- seq_cov(p)
lattice::levelplot(Sigma)
Sigma.eigen <- eigen(Sigma, symmetric=TRUE)
plot(Sigma.eigen$values, type='h')
direction0 <- Sigma.eigen$vectors[,which.min(abs(Sigma.eigen$values))]
maha <- mahalanobis(x = direction0, center = 0, cov = Sigma)
direction <- direction0 *sqrt(p/maha)
RhpcBLASctl::blas_set_num_threads(1)
registerDoMC(cores=100)
pvals.1.9 <- foreach(j=1:n.replications, .combine=rbind) %dopar%{
foreach(effect=effects, .combine=rbind)  %do% {
labels <- sample(c(rep(TRUE, n/2), rep(FALSE,n/2))) # group assignemt labels
## Gaussian noise
.noise <- rmvnorm(n=n, sigma = Sigma)
## Shift alternative:
noise <- .noise
shift <- matrix(effect * direction, nrow=20, ncol=23, byrow = TRUE)
noise[labels,] <- noise[labels,] + shift
## Compute observed statistic
x1 <- noise[labels,]
x2 <- noise[!labels,]
## Asign observations to folds. Use the simple label structure to balance folds.
fold.ids <- balanced_folding(labels, n.folds, balance = balance)
# capture.output(table(fold.ids, labels), file=balance.log, append = TRUE)
# Observables
ts <- list(
Oracle=t_Oracle(x1, x2, Sigma, Sigma),
Hotelling=t_Hotelling(x1, x2, FALSE),
Hotelling.shrink=t_Hotelling(x1, x2, TRUE),
Goeman=t_goeman(x1, x2),
lda.CV.1=t_lda_cv(noise, labels, labels, fold.ids, type=1),
lda.CV.2=t_lda_cv(noise, labels, labels, fold.ids, type=2),
lda.noCV.1=t_lda(noise, labels, noise, labels, type=1),
lda.noCV.2=t_lda(noise, labels, noise, labels, type=2),
sd=t_SD(x1, x2),
svm.CV.1=t_svm_cv(noise, labels, labels, fold.ids, cost=cost.1, type=1),
svm.CV.2=t_svm_cv(noise, labels, labels, fold.ids, cost=cost.2, type=1),
# svm.CV.3=t_svm_cv(noise, labels, labels, fold.ids, cost=cost.1, type=2),
# svm.CV.4=t_svm_cv(noise, labels, labels, fold.ids, cost=cost.2, type=2),
svm.noCV.1=t_svm(noise, labels, noise, labels, cost=cost.1, type=1),
svm.noCV.2=t_svm(noise, labels, noise, labels, cost=cost.2, type=1)
# svm.noCV.3=t_svm(noise, labels, noise, labels, cost=cost.1, type=2),
# svm.noCV.4=t_svm(noise, labels, noise, labels, cost=cost.2, type=2)
)
# Prepare to permute
old.labels <- labels
old.folds.ids <- fold.ids
# Initialize permuted statistics
permuted <- matrix(NA, ncol=length(ts), nrow=n.permutations)
for(i in 1:n.permutations){
# i <- 1
labels <- sample(labels) # make permutation
fold.ids <- balanced_folding(labels, n.folds, balance) # refold
x1 <- noise[labels,]
x2 <- noise[!labels,]
permuted[i,] <- c(
Oracle=t_Oracle(x1, x2, Sigma, Sigma),
Hotelling=t_Hotelling(x1, x2, FALSE),
Hotelling.shrink=t_Hotelling(x1, x2, TRUE),
Goeman=t_goeman(x1, x2),
lda.CV.1=t_lda_cv(noise, labels, labels, fold.ids, type=1),
lda.CV.2=t_lda_cv(noise, labels, labels, fold.ids, type=2),
lda.noCV.1=t_lda(noise, labels, noise, labels, type=1),
lda.noCV.2=t_lda(noise, labels, noise, labels, type=2),
sd=t_SD(x1, x2),
svm.CV.1=t_svm_cv(noise, labels, labels, fold.ids, cost=cost.1, type=1),
svm.CV.2=t_svm_cv(noise, labels, labels, fold.ids, cost=cost.2, type=1),
# svm.CV.3=t_svm_cv(noise, labels, labels, fold.ids, cost=cost.1, type=2),
# svm.CV.4=t_svm_cv(noise, labels, labels, fold.ids, cost=cost.2, type=2),
svm.noCV.1=t_svm(noise, labels, noise, labels, cost=cost.1, type=1),
svm.noCV.2=t_svm(noise, labels, noise, labels, cost=cost.2, type=1)
# svm.noCV.3=t_svm(noise, labels, noise, labels, cost=cost.1, type=2),
# svm.noCV.4=t_svm(noise, labels, noise, labels, cost=cost.2, type=2)
)
} # End permutation
## Compute p-vals for each statistic
pvals <- rep(NA, length(ts))
for(i in seq_along(ts)){
pvals[i] <- mean(ts[i]<=permuted[,i], na.rm=TRUE)
}
names(pvals) <- names(ts)
c(effect=effect, pvals)
}
}
pbPost(type = "note", body = "Done", the.message)
save.image(file=paste(file.name,".RData", sep=''))
# load("file21.RData")
source('prepare_graphics.R')
plot.3
# load("file21.RData")
source('prepare_graphics.R')
plot.3
pdf(file = paste('Output/',file.name,'.pdf', sep=''))
plot.3
dev.off()
file.name <- "file1"
setwd('~/workspace/permuting_accuracy/Round3/')
balance <- TRUE   # set for TRUE for balanced folding ana refolding.
n.replications <-  1e2
large.sample <- 1e2
p <- 23*large.sample
n <- 40*large.sample # total sample size-> n/2 in each group.
n.permutations <- 1e2
n.folds <- 2
source('Gilron Effect of Cross Validatino.R')
effects <- seq(0, 0.5, length=3) # change in location
Sigma <- diag(p)
# lattice::levelplot(Sigma)
direction0 <- rep(1,p)
maha <- direction0 %*% solve(Sigma) %*% direction0 %>% c
direction <- 23 * direction0 / sqrt(n/2*maha)
n*p
rnorm(n*p)
## Gaussian noise
.noise <- matrix(rnorm(n*p), ncol = p, nrow=n)
## Gaussian noise
system.time(rmvnorm(n=n, sigma = Sigma))
.noise <- matrix(rnorm(n*p), ncol = p, nrow=n)
system.time(.noise <- matrix(rnorm(n*p), ncol = p, nrow=n))
labels <- sample(c(rep(TRUE, n/2), rep(FALSE,n/2))) # group assignemt labels
## Gaussian noise
.noise <- matrix(rnorm(n*p), ncol = p, nrow=n)
noise <- .noise
shift <- matrix(effect * direction, nrow=n/2, ncol=p, byrow = TRUE)
effect <- effects[[3]]
noise <- .noise
shift <- matrix(effect * direction, nrow=n/2, ncol=p, byrow = TRUE)
noise[labels,] <- noise[labels,] + shift
## Compute observed statistic
x1 <- noise[labels,]
x2 <- noise[!labels,]
## Asign observations to folds. Use the simple label structure to balance folds.
fold.ids <- balanced_folding(labels, n.folds, balance = balance)
# Observables
ts <- statisticsLargeSample(x1,x2,Sigma,noise,labels,fold.ids,cost.1,cost.2)
## Gaussian noise
dim(rmvnorm(n=n, sigma = Sigma))
dim(.noise <- matrix(rnorm(n*p), ncol = p, nrow=n))
file.name <- "file1"
setwd('~/workspace/permuting_accuracy/Round3/')
balance <- TRUE   # set for TRUE for balanced folding ana refolding.
n.replications <-  1e2
large.sample <- 1e2
p <- 23*large.sample
n <- 40*large.sample # total sample size-> n/2 in each group.
n.permutations <- 1e2
n.folds <- 2
source('Gilron Effect of Cross Validatino.R')
effects <- seq(0, 0.5, length=3) # change in location
Sigma <- diag(p)
direction0 <- rep(1,p)
maha <- direction0 %*% solve(Sigma) %*% direction0 %>% c
direction <- 23 * direction0 / sqrt(n/2*maha)
RhpcBLASctl::blas_set_num_threads(1)
registerDoMC(cores=100)
pvals.1.9 <- foreach(j=1:n.replications, .combine=rbind) %dopar%{
foreach(effect=effects, .combine=rbind)  %do% {
labels <- sample(c(rep(TRUE, n/2), rep(FALSE,n/2))) # group assignemt labels
## Gaussian noise
# system.time(rmvnorm(n=n, sigma = Sigma))
.noise <- matrix(rnorm(n*p), ncol = p, nrow=n)
## Shift alternative:
# effect <- effects[[3]]
noise <- .noise
shift <- matrix(effect * direction, nrow=n/2, ncol=p, byrow = TRUE)
noise[labels,] <- noise[labels,] + shift
## Compute observed statistic
x1 <- noise[labels,]
x2 <- noise[!labels,]
## Asign observations to folds. Use the simple label structure to balance folds.
fold.ids <- balanced_folding(labels, n.folds, balance = balance)
# capture.output(table(fold.ids, labels), file=balance.log, append = TRUE)
# Observables
ts <- statisticsLargeSample(x1,x2,Sigma,noise,labels,fold.ids,cost.1,cost.2)
# Prepare to permute
old.labels <- labels
old.folds.ids <- fold.ids
# Initialize permuted statistics
permuted <- matrix(NA, ncol=length(ts), nrow=n.permutations)
for(i in 1:n.permutations){
# i <- 1
labels <- sample(labels) # make permutation
fold.ids <- balanced_folding(labels, n.folds, balance) # refold
x1 <- noise[labels,]
x2 <- noise[!labels,]
permuted[i,] <- statisticsLargeSample(x1,x2,Sigma,noise,labels,fold.ids,cost.1,cost.2)
} # End permutation
# Compute p-vals for each statistic
pvals <- rep(NA, length(ts))
for(i in seq_along(ts)){
pvals[i] <- mean(ts[i]<=permuted[,i], na.rm=TRUE)
}
names(pvals) <- names(ts)
c(effect=effect, pvals)
}
}
pbPost(type = "note", body = "Done", the.message)
save.image(file=paste(file.name,".RData", sep=''))
library(xgboost)
load('file1.RData')
source('prepare_graphics.R')
plot(plot.3)
library(RcppZiggurat)
file.name <- "file1"
setwd('~/workspace/permuting_accuracy/Round3/')
library(RcppZiggurat)
balance <- TRUE   # set for TRUE for balanced folding ana refolding.
n.replications <-  1.5e2
large.sample <- 1e2
large.sample <- 1e1
p <- 23*large.sample
n <- 40*large.sample # total sample size-> n/2 in each group.
n.permutations <- 1e2
n.folds <- 2
source('Gilron Effect of Cross Validatino.R')
install.packages('mvtnorm')
suppressPackageStartupMessages(library(magrittr))
suppressPackageStartupMessages(library(mvtnorm))
suppressPackageStartupMessages(library(foreach))
suppressPackageStartupMessages(library(doMC))
suppressPackageStartupMessages(library(lattice))
suppressPackageStartupMessages(library(gap))
install.packages('gap')
suppressPackageStartupMessages(library(mvtnorm))
suppressPackageStartupMessages(library(foreach))
suppressPackageStartupMessages(library(doMC))
suppressPackageStartupMessages(library(lattice))
suppressPackageStartupMessages(library(gap))
suppressPackageStartupMessages(library(e1071))
install.packages("e1071")
suppressPackageStartupMessages(library(e1071))
suppressPackageStartupMessages(library(Hotelling))
install.packages("Hotelling")
suppressPackageStartupMessages(library(Hotelling))
suppressPackageStartupMessages(library(MASS))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(caret))
suppressPackageStartupMessages(library(RPushbullet))
install.packages("RPushbullet")
suppressPackageStartupMessages(library(reshape2))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(plotly))
suppressPackageStartupMessages(library(sparsediscrim))
install.packages("sparsediscrim")
# suppressPackageStartupMessages(library(sparsediscrim))
suppressPackageStartupMessages(library(glmnet))
install.packages("glmnet")
suppressPackageStartupMessages(library(LiblineaR))
install.packages("LiblineaR")
suppressPackageStartupMessages(library(data.table))
# source("https://bioconductor.org/biocLite.R")
# biocLite("globaltest")
suppressPackageStartupMessages(library('globaltest'))
source("https://bioconductor.org/biocLite.R")
biocLite("globaltest")
# source("https://bioconductor.org/biocLite.R")
# biocLite("globaltest")
suppressPackageStartupMessages(library('globaltest'))
suppressPackageStartupMessages(library(RobPer))
install.packages("RobPer")
suppressPackageStartupMessages(library(RobPer))
# suppressPackageStartupMessages(library(fungible))
suppressPackageStartupMessages(library(kernlab))
suppressPackageStartupMessages(library(energy))
install.packages("energy")
suppressPackageStartupMessages(library(energy))
suppressPackageStartupMessages(library(HDtest))
install.packages("HDtest")
install.packages(c("kernlab", "lava", "ModelMetrics", "pls"))
file.name <- "file1"
setwd('~/workspace/permuting_accuracy/Round3/')
library(RcppZiggurat)
setwd('~/workspace/permuting_accuracy/Round3/')
balance <- TRUE   # set for TRUE for balanced folding ana refolding.
n.replications <-  1.5e2
large.sample <- 1e1
p <- 23*large.sample
n <- 40*large.sample # total sample size-> n/2 in each group.
n.permutations <- 1e2
n.folds <- 2
p <- 23*large.sample
n <- 40*large.sample # total sample size-> n/2 in each group.
n.permutations <- 1e2
n.folds <- 2
source('Gilron Effect of Cross Validatino.R')
n.replications <-  1.5e2
Sigma <- diag(p)
direction0 <- rep(1,p)
maha <- direction0 %*% solve(Sigma) %*% direction0 %>% c
direction <- 23 * direction0 / sqrt(n/2*maha)
RhpcBLASctl::blas_set_num_threads(1)
install.packages("RhpcBLASctl")
RhpcBLASctl::blas_set_num_threads(1)
registerDoMC(cores=100)
zrnorm
file.name <- "file1"
setwd('~/workspace/permuting_accuracy/Round3/')
balance <- TRUE   # set for TRUE for balanced folding ana refolding.
large.sample <- 1e0
p <- 23*large.sample
n <- 40*large.sample # total sample size-> n/2 in each group.
n.permutations <- 1e2
n.folds <- 2
source('Gilron Effect of Cross Validatino.R')
n.replications <-  1.5e2
# effects <- seq(0, 0.5, length=3) # change in location
Sigma <- diag(p)
direction0 <- rep(1,p)
maha <- direction0 %*% solve(Sigma) %*% direction0 %>% c
direction <- 23 * direction0 / sqrt(n/2*maha)
RhpcBLASctl::blas_set_num_threads(1)
registerDoMC(cores=100)
pvals.1.9 <- foreach(j=1:n.replications, .combine=rbind) %dopar%{
foreach(effect=effects, .combine=rbind)  %do% {
labels <- sample(c(rep(TRUE, n/2), rep(FALSE,n/2))) # group assignemt labels
## Gaussian noise
# system.time(rmvnorm(n=n, sigma = Sigma))
.noise <- matrix(zrnorm(n*p), ncol = p, nrow=n)
## Shift alternative:
# effect <- effects[[3]]
noise <- .noise
shift <- matrix(effect * direction, nrow=n/2, ncol=p, byrow = TRUE)
noise[labels,] <- noise[labels,] + shift
## Compute observed statistic
x1 <- noise[labels,]
x2 <- noise[!labels,]
## Asign observations to folds. Use the simple label structure to balance folds.
fold.ids <- balanced_folding(labels, n.folds, balance = balance)
# capture.output(table(fold.ids, labels), file=balance.log, append = TRUE)
# Observables
ts <- statistics(x1,x2,Sigma,noise,labels,fold.ids,cost.1,cost.2)
# Prepare to permute
old.labels <- labels
old.folds.ids <- fold.ids
# Initialize permuted statistics
permuted <- matrix(NA, ncol=length(ts), nrow=n.permutations)
for(i in 1:n.permutations){
# i <- 1
labels <- sample(labels) # make permutation
fold.ids <- balanced_folding(labels, n.folds, balance) # refold
x1 <- noise[labels,]
x2 <- noise[!labels,]
permuted[i,] <- statistics(x1,x2,Sigma,noise,labels,fold.ids,cost.1,cost.2)
} # End permutation
# Compute p-vals for each statistic
pvals <- rep(NA, length(ts))
for(i in seq_along(ts)){
pvals[i] <- mean(ts[i]<=permuted[,i], na.rm=TRUE)
}
names(pvals) <- names(ts)
c(effect=effect, pvals)
}
}
pbPost(type = "note", body = "Done", the.message)
save.image(file=paste(file.name,".RData", sep=''))
labels <- sample(c(rep(TRUE, n/2), rep(FALSE,n/2))) # group assignemt labels
## Gaussian noise
# system.time(rmvnorm(n=n, sigma = Sigma))
.noise <- matrix(zrnorm(n*p), ncol = p, nrow=n)
noise <- .noise
shift <- matrix(effect * direction, nrow=n/2, ncol=p, byrow = TRUE)
effect <- effects[[3]]
noise <- .noise
shift <- matrix(effect * direction, nrow=n/2, ncol=p, byrow = TRUE)
effect <- effects[[3]]
effects <- seq(0, 0.5, length=3) # change in location
Sigma <- diag(p)
direction0 <- rep(1,p)
maha <- direction0 %*% solve(Sigma) %*% direction0 %>% c
direction <- 23 * direction0 / sqrt(n/2*maha)
RhpcBLASctl::blas_set_num_threads(1)
registerDoMC(cores=100)
effect <- effects[[3]]
noise <- .noise
shift <- matrix(effect * direction, nrow=n/2, ncol=p, byrow = TRUE)
noise[labels,] <- noise[labels,] + shift
## Compute observed statistic
x1 <- noise[labels,]
x2 <- noise[!labels,]
## Asign observations to folds. Use the simple label structure to balance folds.
fold.ids <- balanced_folding(labels, n.folds, balance = balance)
file.name <- "file1"
setwd('~/workspace/permuting_accuracy/Round3/')
balance <- TRUE   # set for TRUE for balanced folding ana refolding.
large.sample <- 1e0
p <- 23*large.sample
n <- 40*large.sample # total sample size-> n/2 in each group.
n.permutations <- 1e2
n.folds <- 2
source('Gilron Effect of Cross Validatino.R')
n.replications <-  1.5e2
effects <- seq(0, 0.5, length=3) # change in location
Sigma <- diag(p)
direction0 <- rep(1,p)
maha <- direction0 %*% solve(Sigma) %*% direction0 %>% c
direction <- 23 * direction0 / sqrt(n/2*maha)
RhpcBLASctl::blas_set_num_threads(1)
registerDoMC(cores=100)
pvals.1.9 <- foreach(j=1:n.replications, .combine=rbind) %dopar%{
foreach(effect=effects, .combine=rbind)  %do% {
labels <- sample(c(rep(TRUE, n/2), rep(FALSE,n/2))) # group assignemt labels
## Gaussian noise
# system.time(rmvnorm(n=n, sigma = Sigma))
.noise <- matrix(zrnorm(n*p), ncol = p, nrow=n)
## Shift alternative:
# effect <- effects[[3]]
noise <- .noise
shift <- matrix(effect * direction, nrow=n/2, ncol=p, byrow = TRUE)
noise[labels,] <- noise[labels,] + shift
## Compute observed statistic
x1 <- noise[labels,]
x2 <- noise[!labels,]
## Asign observations to folds. Use the simple label structure to balance folds.
fold.ids <- balanced_folding(labels, n.folds, balance = balance)
# capture.output(table(fold.ids, labels), file=balance.log, append = TRUE)
# Observables
ts <- statistics(x1,x2,Sigma,noise,labels,fold.ids,cost.1,cost.2)
# Prepare to permute
old.labels <- labels
old.folds.ids <- fold.ids
# Initialize permuted statistics
permuted <- matrix(NA, ncol=length(ts), nrow=n.permutations)
for(i in 1:n.permutations){
# i <- 1
labels <- sample(labels) # make permutation
fold.ids <- balanced_folding(labels, n.folds, balance) # refold
x1 <- noise[labels,]
x2 <- noise[!labels,]
permuted[i,] <- statistics(x1,x2,Sigma,noise,labels,fold.ids,cost.1,cost.2)
} # End permutation
# Compute p-vals for each statistic
pvals <- rep(NA, length(ts))
for(i in seq_along(ts)){
pvals[i] <- mean(ts[i]<=permuted[,i], na.rm=TRUE)
}
names(pvals) <- names(ts)
c(effect=effect, pvals)
}
}
pbPost(type = "note", body = "Done", the.message)
save.image(file=paste(file.name,".RData", sep=''))
source('prepare_graphics.R')
plot(plot.3)
file.name <- "file1"
setwd('~/workspace/permuting_accuracy/Round3/')
balance <- TRUE   # set for TRUE for balanced folding ana refolding.
large.sample <- 1e1
p <- 23*large.sample
n <- 40*large.sample # total sample size-> n/2 in each group.
n.permutations <- 1e2
n.folds <- 2
source('Gilron Effect of Cross Validatino.R')
n.replications <-  1.5e2
effects <- seq(0, 0.5, length=3) # change in location
Sigma <- diag(p)
direction0 <- rep(1,p)
maha <- direction0 %*% solve(Sigma) %*% direction0 %>% c
direction <- 23 * direction0 / sqrt(n/2*maha)
RhpcBLASctl::blas_set_num_threads(1)
registerDoMC(cores=100)
pvals.1.9 <- foreach(j=1:n.replications, .combine=rbind) %dopar%{
foreach(effect=effects, .combine=rbind)  %do% {
labels <- sample(c(rep(TRUE, n/2), rep(FALSE,n/2))) # group assignemt labels
## Gaussian noise
# system.time(rmvnorm(n=n, sigma = Sigma))
.noise <- matrix(zrnorm(n*p), ncol = p, nrow=n)
## Shift alternative:
# effect <- effects[[3]]
noise <- .noise
shift <- matrix(effect * direction, nrow=n/2, ncol=p, byrow = TRUE)
noise[labels,] <- noise[labels,] + shift
## Compute observed statistic
x1 <- noise[labels,]
x2 <- noise[!labels,]
## Asign observations to folds. Use the simple label structure to balance folds.
fold.ids <- balanced_folding(labels, n.folds, balance = balance)
# capture.output(table(fold.ids, labels), file=balance.log, append = TRUE)
# Observables
ts <- statistics(x1,x2,Sigma,noise,labels,fold.ids,cost.1,cost.2)
# Prepare to permute
old.labels <- labels
old.folds.ids <- fold.ids
# Initialize permuted statistics
permuted <- matrix(NA, ncol=length(ts), nrow=n.permutations)
for(i in 1:n.permutations){
# i <- 1
labels <- sample(labels) # make permutation
fold.ids <- balanced_folding(labels, n.folds, balance) # refold
x1 <- noise[labels,]
x2 <- noise[!labels,]
permuted[i,] <- statistics(x1,x2,Sigma,noise,labels,fold.ids,cost.1,cost.2)
} # End permutation
# Compute p-vals for each statistic
pvals <- rep(NA, length(ts))
for(i in seq_along(ts)){
pvals[i] <- mean(ts[i]<=permuted[,i], na.rm=TRUE)
}
names(pvals) <- names(ts)
c(effect=effect, pvals)
}
}
pbPost(type = "note", body = "Done", the.message)
save.image(file=paste(file.name,".RData", sep=''))
n.permutations <- 1e2
n.replications <-  1e2
setwd('~/workspace/permuting_accuracy/Round4/')
file.name <- "file40"
