svm.CV.4=t_svm_cv(noise, labels, labels, fold.ids, cost=cost.2, type=2),
svm.noCV.1=t_svm(noise, labels, noise, labels, cost=cost.1, type=1),
svm.noCV.2=t_svm(noise, labels, noise, labels, cost=cost.2, type=1),
svm.noCV.3=t_svm(noise, labels, noise, labels, cost=cost.1, type=2),
svm.noCV.4=t_svm(noise, labels, noise, labels, cost=cost.2, type=2)
)
# Prepare to permute
old.labels <- labels
old.folds.ids <- fold.ids
statistics.names <- names(ts)
# Initialize permuted statistics
permuted <- matrix(NA, ncol=length(ts), nrow=n.permutations)
for(i in 1:n.permutations){
# i <- 1
labels <- sample(labels) # make permutation
fold.ids <- balanced_folding(labels, n.folds, balance) # refold
x1 <- noise[labels,]
x2 <- noise[!labels,]
permuted[i,] <- c(
Oracle=t_Oracle(x1, x2, Sigma, Sigma),
Hotelling=t_Hotelling(x1, x2, FALSE),
Hotelling.shrink=t_Hotelling(x1, x2, TRUE),
lda.CV.1=t_lda_cv(noise, labels, labels, fold.ids, type=1),
lda.CV.2=t_lda_cv(noise, labels, labels, fold.ids, type=2),
lda.noCV.1=t_lda(noise, labels, noise, labels, type=1),
lda.noCV.2=t_lda(noise, labels, noise, labels, type=2),
sd=t_SD(x1, x2),
svm.CV.1=t_svm_cv(noise, labels, labels, fold.ids, cost=cost.1, type=1),
svm.CV.2=t_svm_cv(noise, labels, labels, fold.ids, cost=cost.2, type=1),
svm.CV.3=t_svm_cv(noise, labels, labels, fold.ids, cost=cost.1, type=2),
svm.CV.4=t_svm_cv(noise, labels, labels, fold.ids, cost=cost.2, type=2),
svm.noCV.1=t_svm(noise, labels, noise, labels, cost=cost.1, type=1),
svm.noCV.2=t_svm(noise, labels, noise, labels, cost=cost.2, type=1),
svm.noCV.3=t_svm(noise, labels, noise, labels, cost=cost.1, type=2),
svm.noCV.4=t_svm(noise, labels, noise, labels, cost=cost.2, type=2)
)
} # End permutation
# Compute p-vals for each statistic
pvals <- rep(NA, length(ts))
for(i in seq_along(ts)){
pvals[i] <- mean(ts[i]<=permuted[,i], na.rm=TRUE)
>>>>>>> ec6dda74c9338e4c2622f9a17e644d8ecc6596d0
}
c(effect=effect, pvals)
}
}
pbPost(type = "note", body = "Done", the.message)
save.image(file=paste(file.name,".RData", sep=''))
# load("file1.RData")
err.bar <- round(3*sqrt(.05*.95/(n.replications)),3) # confidence limits of p-value
.limits <- 0.05 + c(-err.bar,0,err.bar)
pvals.1.9 %<>%  as.data.table()
names(pvals.1.9)[-1] <- c('Oracle','Hotelling','Hotelling.shrink', 'LDA.CV.1', 'LDA.CV.2', 'LDA.noCV.1', 'LDA.noCV.2',  'SD','SVM.CV.1', 'SVM.CV.2', 'SVM.CV.3',  'SVM.CV.4','SVM.noCV.1', 'SVM.noCV.2', 'SVM.noCV.3','SVM.noCV.4')
pvals.melt <- melt(pvals.1.9, id.vars=c("effect"), variable.name='statistic')
statistic.filter <- c("SVM.CV.3","SVM.CV.4","SVM.noCV.3","SVM.noCV.4")
pvals.melt <- pvals.melt[!(statistic %in% statistic.filter),,]
pvals.melt[,c("reject","effect.factor"):=list(as.numeric(value <= 0.05), as.factor(effect)),]
# load("file1.RData")
err.bar <- round(3*sqrt(.05*.95/(n.replications)),3) # confidence limits of p-value
.limits <- 0.05 + c(-err.bar,0,err.bar)
pvals.1.9 %<>%  as.data.table()
names(pvals.1.9)[-1] <- c('Oracle','Hotelling','Hotelling.shrink', 'LDA.CV.1', 'LDA.CV.2', 'LDA.noCV.1', 'LDA.noCV.2',  'SD','SVM.CV.1', 'SVM.CV.2', 'SVM.CV.3',  'SVM.CV.4','SVM.noCV.1', 'SVM.noCV.2', 'SVM.noCV.3','SVM.noCV.4')
pvals.melt <- melt(pvals.1.9, id.vars=c("effect"), variable.name='statistic')
statistic.filter <- c("SVM.CV.3","SVM.CV.4","SVM.noCV.3","SVM.noCV.4")
pvals.melt <- pvals.melt[!(statistic %in% statistic.filter),,]
pvals.melt[,c("reject","effect.factor"):=list(as.numeric(value <= 0.05), as.factor(effect)),]
plot.3 <- pvals.melt %>%
ggplot(aes(y=reject, x=statistic, group=effect.factor, shape=effect.factor, color=effect.factor)) +
theme_bw(base_size = 20)+
theme(legend.position="none")+
# ggtitle("Fixed signal, Gaussian Noise")+
ylab('Power')+
xlab('')+
stat_summary(fun.y='mean', geom="point", cex=4) +
geom_hline(yintercept=0.05, lty=2)+
geom_vline(xintercept=.limits, lty=c(3,2,3))+
coord_flip()
plot.3
pdf(file = paste('Output/',file.name,'.pdf', sep=''))
plot.3
dev.off()
source('Gilron Effect of Cross Validatino.R')
file.name <- "file14"
balance <- TRUE   # Set for TRUE for balanced folding ana refolding.
n.replications <-  5e1# 1e3
p <- 23
n <- 4e2 # total sample size-> n/2 in each group.
n.permutations <- 3e2
n.folds <- 4
cost.1 <- 1e1
cost.2 <- 1e-1
## Signal in location
effects <- seq(0, 0.5, length=3) # change in location
## Signal in scale
Sigma <- diag(p)
library(RhpcBLASctl)
blas_set_num_threads(1)
registerDoMC(cores=110)
pvals.1.9 <- foreach(j=1:n.replications, .combine=rbind) %dopar%{
foreach(effect=effects, .combine=rbind)  %do% {
# effect <- effects[[3]]
labels <- sample(c(rep(TRUE, n/2), rep(FALSE,n/2))) # group assignemt labels
## Gaussian noise
.noise <- rmvnorm(n=n, sigma = Sigma)
# Shift alternative:
noise <- .noise + effect * labels
## Compute observed statistic
x1 <- noise[labels,]
x2 <- noise[!labels,]
## Asign observations to folds. Use the simple label structure to balance folds.
fold.ids <- balanced_folding(labels, n.folds, balance = balance)
# capture.output(table(fold.ids, labels), file=balance.log, append = TRUE)
# Observables
ts <- list(
Oracle=t_Oracle(x1, x2, Sigma, Sigma),
Hotelling=t_Hotelling(x1, x2, FALSE),
Hotelling.shrink=t_Hotelling(x1, x2, TRUE),
sd=t_SD(x1, x2),
lda.CV.1=t_lda_cv(noise, labels, labels, fold.ids, type=1),
svm.CV.1=t_svm_cv(noise, labels, labels, fold.ids, cost=1e1, type=1),
svm.CV.2=t_svm_cv(noise, labels, labels, fold.ids, cost=1e-1, type=1),
svm.CV.5=t_svm_cv(noise, labels, labels, fold.ids, cost=1e2, type=1),
svm.CV.6=t_svm_cv(noise, labels, labels, fold.ids, cost=1e-2, type=1),
lda.highdim.1=t_dlda_cv(noise, labels, labels, fold.ids, type=1),
lda.highdim.2=t_hdrda_cv(noise, labels, labels, fold.ids, type=1),
lda.highdim.3=t_sdlda_cv(noise, labels, labels, fold.ids, type=1),
lda.highdim.4=t_sdlda_boot(noise, labels, B=50, type2=1, type=1),
# svm.highdim.1=t_svml2_cv(noise, labels, labels, fold.ids, cost=1e-1, type=1),
svm.highdim.2=t_svm_highdim_boot(noise, labels, B=50, type2=1, cost=1e-1, type=1)
)
# Prepare to permute
old.labels <- labels
old.folds.ids <- fold.ids
statistics.names <- names(ts)
# Initialize permuted statistics
permuted <- matrix(NA, ncol=length(ts), nrow=n.permutations)
for(i in 1:n.permutations){
# i <- 1
labels <- sample(labels) # make permutation
fold.ids <- balanced_folding(labels, n.folds, balance) # refold
x1 <- noise[labels,]
x2 <- noise[!labels,]
# Checking balance:
# capture.output(table(.fold.ids, .labels), file=balanc.log, append = TRUE)
# for permuting Xs:
# .indexes <- sample(seq(n))
#  .noise <- noise[.indexes,]
permuted[i,] <- c(
Oracle=t_Oracle(x1, x2, Sigma, Sigma),
Hotelling=t_Hotelling(x1, x2, FALSE),
Hotelling.shrink=t_Hotelling(x1, x2, TRUE),
sd=t_SD(x1, x2),
lda.CV.1=t_lda_cv(noise, labels, labels, fold.ids, type=1),
svm.CV.1=t_svm_cv(noise, labels, labels, fold.ids, cost=1e1, type=1),
svm.CV.2=t_svm_cv(noise, labels, labels, fold.ids, cost=1e-1, type=1),
svm.CV.5=t_svm_cv(noise, labels, labels, fold.ids, cost=1e2, type=1),
svm.CV.6=t_svm_cv(noise, labels, labels, fold.ids, cost=1e-2, type=1),
lda.highdim.1=t_dlda_cv(noise, labels, labels, fold.ids, type=1),
lda.highdim.2=t_hdrda_cv(noise, labels, labels, fold.ids, type=1),
lda.highdim.3=t_sdlda_cv(noise, labels, labels, fold.ids, type=1),
lda.highdim.4=t_sdlda_boot(noise, labels, B=50, type2=1, type=1),
# svm.highdim.1=t_svml2_cv(noise, labels, labels, fold.ids, cost=1e-1, type=1),
svm.boot.2=t_svm_highdim_boot(noise, labels, B=50, type2=1, cost=1e-1, type=1)
)
} # End permutation
# Compute p-vals for each statistic
pvals <- rep(NA, length(ts))
for(i in seq_along(ts)){
pvals[i] <- mean(ts[i]<=permuted[,i], na.rm=TRUE)
}
c(effect=effect, pvals)
}
}
effect <- effects[[3]]
labels <- sample(c(rep(TRUE, n/2), rep(FALSE,n/2))) # group assignemt labels
## Gaussian noise
.noise <- rmvnorm(n=n, sigma = Sigma)
# Shift alternative:
noise <- .noise + effect * labels
## Compute observed statistic
x1 <- noise[labels,]
x2 <- noise[!labels,]
## Asign observations to folds. Use the simple label structure to balance folds.
fold.ids <- balanced_folding(labels, n.folds, balance = balance)
# Observables
ts <- list(
Oracle=t_Oracle(x1, x2, Sigma, Sigma),
Hotelling=t_Hotelling(x1, x2, FALSE),
Hotelling.shrink=t_Hotelling(x1, x2, TRUE),
sd=t_SD(x1, x2),
lda.CV.1=t_lda_cv(noise, labels, labels, fold.ids, type=1),
svm.CV.1=t_svm_cv(noise, labels, labels, fold.ids, cost=1e1, type=1),
svm.CV.2=t_svm_cv(noise, labels, labels, fold.ids, cost=1e-1, type=1),
svm.CV.5=t_svm_cv(noise, labels, labels, fold.ids, cost=1e2, type=1),
svm.CV.6=t_svm_cv(noise, labels, labels, fold.ids, cost=1e-2, type=1),
lda.highdim.1=t_dlda_cv(noise, labels, labels, fold.ids, type=1),
lda.highdim.2=t_hdrda_cv(noise, labels, labels, fold.ids, type=1),
lda.highdim.3=t_sdlda_cv(noise, labels, labels, fold.ids, type=1),
lda.highdim.4=t_sdlda_boot(noise, labels, B=50, type2=1, type=1),
# svm.highdim.1=t_svml2_cv(noise, labels, labels, fold.ids, cost=1e-1, type=1),
svm.highdim.2=t_svm_highdim_boot(noise, labels, B=50, type2=1, cost=1e-1, type=1)
)
traceback()
options(error=recover)
# Observables
ts <- list(
Oracle=t_Oracle(x1, x2, Sigma, Sigma),
Hotelling=t_Hotelling(x1, x2, FALSE),
Hotelling.shrink=t_Hotelling(x1, x2, TRUE),
sd=t_SD(x1, x2),
lda.CV.1=t_lda_cv(noise, labels, labels, fold.ids, type=1),
svm.CV.1=t_svm_cv(noise, labels, labels, fold.ids, cost=1e1, type=1),
svm.CV.2=t_svm_cv(noise, labels, labels, fold.ids, cost=1e-1, type=1),
svm.CV.5=t_svm_cv(noise, labels, labels, fold.ids, cost=1e2, type=1),
svm.CV.6=t_svm_cv(noise, labels, labels, fold.ids, cost=1e-2, type=1),
lda.highdim.1=t_dlda_cv(noise, labels, labels, fold.ids, type=1),
lda.highdim.2=t_hdrda_cv(noise, labels, labels, fold.ids, type=1),
lda.highdim.3=t_sdlda_cv(noise, labels, labels, fold.ids, type=1),
lda.highdim.4=t_sdlda_boot(noise, labels, B=50, type2=1, type=1),
# svm.highdim.1=t_svml2_cv(noise, labels, labels, fold.ids, cost=1e-1, type=1),
svm.highdim.2=t_svm_highdim_boot(noise, labels, B=50, type2=1, cost=1e-1, type=1)
)
ts
ts
# Observables
ts <- list(
Oracle=t_Oracle(x1, x2, Sigma, Sigma),
Hotelling=t_Hotelling(x1, x2, FALSE),
Hotelling.shrink=t_Hotelling(x1, x2, TRUE),
sd=t_SD(x1, x2),
lda.CV.1=t_lda_cv(noise, labels, labels, fold.ids, type=1),
svm.CV.1=t_svm_cv(noise, labels, labels, fold.ids, cost=1e1, type=1),
svm.CV.2=t_svm_cv(noise, labels, labels, fold.ids, cost=1e-1, type=1),
svm.CV.5=t_svm_cv(noise, labels, labels, fold.ids, cost=1e2, type=1),
svm.CV.6=t_svm_cv(noise, labels, labels, fold.ids, cost=1e-2, type=1),
lda.highdim.1=t_dlda_cv(noise, labels, labels, fold.ids, type=1),
lda.highdim.2=t_hdrda_cv(noise, labels, labels, fold.ids, type=1),
lda.highdim.3=t_sdlda_cv(noise, labels, labels, fold.ids, type=1),
lda.highdim.4=t_sdlda_boot(noise, labels, B=50, type2=1, type=1),
# svm.highdim.1=t_svml2_cv(noise, labels, labels, fold.ids, cost=1e-1, type=1),
svm.highdim.2=t_svm_highdim_boot(noise, labels, B=50, type2=1, cost=1e-1, type=1)
)
traceback()
svm.highdim.2=t_svm_highdim_boot(noise, labels, B=50, type2=1, cost=1e-1, type=1)
svm.highdim.2=t_svm_highdim_boot(noise, labels, B=50, type2=1, cost=1e-1, type=1)
t_sdlda_boot(noise, labels, B=50, type2=1, type=1)
t_sdlda_boot(noise, labels, B=50, type2=1, type=1)
## Testing:
t_sdlda_boot(noise, labels, B=50, type2=1, type=1)
x
ls()
ls()
x
source('~/workspace/permuting_accuracy/Round1/Gilron Effect of Cross Validatino.R')
t_sdlda_boot(noise, labels, B=50, type2=1, type=1)
t_sdlda_boot(noise, labels, B=50, type2=1, type=1)
effect <- effects[[2]]
labels <- sample(c(rep(TRUE, n/2), rep(FALSE,n/2))) # group assignemt labels
## Gaussian noise
.noise <- rmvnorm(n=n, sigma = Sigma)
# Shift alternative:
# effect <- effects[[2]]
noise <- .noise + effect * labels
## Compute observed statistic
x1 <- noise[labels,]
x2 <- noise[!labels,]
## Asign observations to folds. Use the simple label structure to balance folds.
fold.ids <- balanced_folding(labels, n.folds, balance = balance)
# Observables
ts <- list(
Oracle=t_Oracle(x1, x2, Sigma, Sigma),
Hotelling=t_Hotelling(x1, x2, FALSE),
Hotelling.shrink=t_Hotelling(x1, x2, TRUE),
sd=t_SD(x1, x2),
lda.CV.1=t_lda_cv(noise, labels, labels, fold.ids, type=1),
svm.CV.1=t_svm_cv(noise, labels, labels, fold.ids, cost=1e1, type=1),
svm.CV.2=t_svm_cv(noise, labels, labels, fold.ids, cost=1e-1, type=1),
svm.CV.5=t_svm_cv(noise, labels, labels, fold.ids, cost=1e2, type=1),
svm.CV.6=t_svm_cv(noise, labels, labels, fold.ids, cost=1e-2, type=1),
lda.highdim.1=t_dlda_cv(noise, labels, labels, fold.ids, type=1),
lda.highdim.2=t_hdrda_cv(noise, labels, labels, fold.ids, type=1),
lda.highdim.3=t_sdlda_cv(noise, labels, labels, fold.ids, type=1),
lda.highdim.4=t_sdlda_boot(noise, labels, B=50, type2=1, type=1),
# svm.highdim.1=t_svml2_cv(noise, labels, labels, fold.ids, cost=1e-1, type=1),
svm.highdim.2=t_svm_highdim_boot(noise, labels, B=50, type2=1, cost=1e-1, type=1)
)
t_sdlda_cv(noise, labels, labels, fold.ids, type=1)
t_sdlda_cv(noise, labels, labels, fold.ids, type=1)
t_sdlda_cv(noise, labels, labels, fold.ids, type=1)
source('~/workspace/permuting_accuracy/Round1/Gilron Effect of Cross Validatino.R')
t_sdlda_boot(noise, labels, B=50, type2=1, type=1)
t_sdlda_boot(noise, labels, B=50, type2=1, type=1)
train.noise
dim(train.noise)
dim(train.labels)
labels
t_sdlda_boot(noise, labels, B=50, type2=1, type=1)
train.ind
test.noise
test.labels
train.labels
train.labels <- labels[train.ind]
labels
t_sdlda_boot(noise, labels, B=50, type2=1, type=1)
dim(train.noise)
dim(train.labels)
train.labels
length(train.labels)
lda.1
traceback()
t_sdlda_boot(noise, labels, B=50, type2=1, type=1)
FUN
t_boot <- function(FUN, noise, labels, B, type2, ...){
t.boot <- rep(NA, B) # initialize output container
n.samples <- nrow(noise)
for(b in 1:B){
train.ind <- sample(1:n.samples, replace = TRUE)
train.noise <- noise[train.ind, ]
train.labels <- labels[train.ind]
test.noise <- noise[-train.ind,]
test.labels <- labels[-train.ind]
t.boot[b] <- FUN(train.noise, train.labels, ...)
}
error.boot <- mean(t.boot)
if(type2==2) {
result <- error.boot
}
if(type2==1) {
error.resubstitute <- FUN(noise, labels, noise, labels, ...)
result <- 0.368 * error.resubstitute + 0.632 * error.boot
}
return(result)
}
t_sdlda_boot(noise, labels, B=50, type2=1, type=1)
t_sdlda_boot(noise, labels, B=50, type2=1, type=1)
t_boot <- function(FUN, noise, labels, B, type2, ...){
t.boot <- rep(NA, B) # initialize output container
n.samples <- nrow(noise)
for(b in 1:B){
train.ind <- sample(1:n.samples, replace = TRUE)
train.noise <- noise[train.ind, ]
train.labels <- labels[train.ind]
test.noise <- noise[-train.ind,]
test.labels <- labels[-train.ind]
t.boot[b] <- FUN(train.noise, train.labels, test.noise, test.labels, ...)
}
error.boot <- mean(t.boot)
if(type2==2) {
result <- error.boot
}
if(type2==1) {
error.resubstitute <- FUN(noise, labels, noise, labels, ...)
result <- 0.368 * error.resubstitute + 0.632 * error.boot
}
return(result)
}
file.name <- "file14"
balance <- TRUE   # Set for TRUE for balanced folding ana refolding.
n.replications <-  5e1# 1e3
p <- 23
n <- 4e2 # total sample size-> n/2 in each group.
n.permutations <- 3e2
n.folds <- 4
cost.1 <- 1e1
cost.2 <- 1e-1
## Signal in location
effects <- seq(0, 0.5, length=3) # change in location
## Signal in scale
Sigma <- diag(p)
labels <- sample(c(rep(TRUE, n/2), rep(FALSE,n/2))) # group assignemt labels
## Gaussian noise
.noise <- rmvnorm(n=n, sigma = Sigma)
# Shift alternative:
# effect <- effects[[2]]
noise <- .noise + effect * labels
## Compute observed statistic
x1 <- noise[labels,]
x2 <- noise[!labels,]
## Asign observations to folds. Use the simple label structure to balance folds.
fold.ids <- balanced_folding(labels, n.folds, balance = balance)
t_sdlda_boot(noise, labels, B=50, type2=1, type=1)
options(error=traceback)
t_sdlda_boot(noise, labels, B=50, type2=1, type=1)
dim(train.noise)
train.labels
table(train.labels)
sdlda.default
sparsediscrim::sdlda
sparsediscrim::sdlda.default
sparsediscrim:::sdlda.default
View(sparsediscrim:::sdlda.default)
View(sparsediscrim:::var_shrinkage)
View(sparsediscrim:::risk_stein)
debug(sparsediscrim:::risk_stein)
t_sdlda_boot(noise, labels, B=50, type2=1, type=1)
nu
akohas
alphas
risk_alphas
t_sdlda_boot(noise, labels, B=50, type2=1, type=1)
var_feature
var_pool
t/p
var_feature
h
nu
risk_alphas
alphas
nu
p
h(nu = nu, p = p)
h
View(h)
alpha_min_risk
h(nu = nu, p = 1)
h(nu = 10, p = 1)
h(nu = 100, p = 1)
h(nu = 1000, p = 1)
h(nu = 1000, p = p)
h(nu = 100, p = p)
source('Gilron Effect of Cross Validatino.R')
source('Gilron Effect of Cross Validatino.R')
source('Gilron Effect of Cross Validatino.R')
source('Gilron Effect of Cross Validatino.R')
source('Gilron Effect of Cross Validatino.R')
file.name <- "file14"
balance <- TRUE   # Set for TRUE for balanced folding ana refolding.
n.replications <-  5e1# 1e3
p <- 23
n <- 4e1 # total sample size-> n/2 in each group.
n.permutations <- 3e2
n.folds <- 4
cost.1 <- 1e1
cost.2 <- 1e-1
## Signal in location
effects <- seq(0, 0.5, length=3) # change in location
source('Gilron Effect of Cross Validatino.R')
## Signal in scale
Sigma <- diag(p)
library(RhpcBLASctl)
blas_set_num_threads(1)
registerDoMC(cores=110)
labels <- sample(c(rep(TRUE, n/2), rep(FALSE,n/2))) # group assignemt labels
## Gaussian noise
.noise <- rmvnorm(n=n, sigma = Sigma)
# Shift alternative:
# effect <- effects[[2]]
noise <- .noise + effect * labels
## Compute observed statistic
x1 <- noise[labels,]
x2 <- noise[!labels,]
# Shift alternative:
# effect <- effects[[2]]
noise <- .noise + effect * labels
## Gaussian noise
.noise <- rmvnorm(n=n, sigma = Sigma)
# Shift alternative:
# effect <- effects[[2]]
noise <- .noise + effect * labels
.noise
effect
effect <- effects[[2]]
# Shift alternative:
# effect <- effects[[2]]
noise <- .noise + effect * labels
## Compute observed statistic
x1 <- noise[labels,]
x2 <- noise[!labels,]
## Asign observations to folds. Use the simple label structure to balance folds.
fold.ids <- balanced_folding(labels, n.folds, balance = balance)
?createFolds
??createFolds
??createFolds
## Asign observations to folds. Use the simple label structure to balance folds.
fold.ids <- balanced_folding(labels, n.folds, balance = balance)
version()
Version()
version
version
file.name <- "file14"
balance <- TRUE   # Set for TRUE for balanced folding ana refolding.
n.replications <-  5e1# 1e3
p <- 23
n <- 4e1 # total sample size-> n/2 in each group.
n.permutations <- 3e2
n.folds <- 4
cost.1 <- 1e1
cost.2 <- 1e-1
## Signal in location
effects <- seq(0, 0.5, length=3) # change in location
source('Gilron Effect of Cross Validatino.R')
## Signal in scale
Sigma <- diag(p)
<<<<<<< HEAD
# Sigma <- ar1_cov(p, rho=0.8)
# Sigma <- comSym_cov(p, rho=0.7)
# Sigma <- diag((1:p)*p/sum(1:p))
file.name <- "file2"
the.message <- paste(file.name)
# Or
export OPENBLAS_NUM_THREADS=x
registerDoMC(cores=40)
foreach(i=1:60) %dopar% {
eigen(matrix(rnorm(1e6), ncol = 1e3, nrow = 1e3))
}
registerDoMC(cores=40)
sessionInfo()
install.packages("LiblineaR")
=======
suppressPackageStartupMessages(library(caret))
install.packages("recipes")
>>>>>>> ec6dda74c9338e4c2622f9a17e644d8ecc6596d0
