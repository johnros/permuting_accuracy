data.frame(t=t.t, wilcox=t.wilcox)
}
results.melt <- suppressMessages(melt(null.distributions))
names(results.melt)[1] <- 'Statistic'
tail(results.melt)
# save(cutoffs, file='~/workspace/WilcoxonPower/R/round_3/Rdata/cutoffs_for_paper.RData')
pbPost("note", "Done")
alpha <- 0.05
cutoff.wilcox <- results.melt$value %>%
extract(results.melt$Statistic=='wilcox') %>%
quantile(1-alpha)
cutoff.t <- results.melt$value %>%
extract(results.melt$Statistic=='t') %>%
quantile(1-alpha)
cutoffs <- data.frame(
Statistic=c('wilcox','t'),
cutoff=c(cutoff.wilcox, cutoff.t))
results.sim.melt <- melt(results.sim, id.vars=c("p","mu","eps")) %>% tbl_df
names(results.sim.melt)[4] <- 'Statistic'
results.sim.melt.2 <- left_join(results.sim.melt, cutoffs, by='Statistic', copy=TRUE)
results.sim.melt.2 %<>%
mutate(
reject= as.numeric(value >= cutoff),
eps=round(eps,3))
plot.2.1 <- results.sim.melt.2 %>%
ggplot(aes(y=reject, x=mu, group=Statistic))
plot.3.1 <- plot.2.1 +
# facet_wrap(~eps, scales="free_y") +
facet_wrap(~eps) +
xlab('Signal')+
ylab('Power')+
# ggtitle("Fixed signal, Gaussian Noise") +
theme_bw(base_size = 20) +
stat_summary(aes(shape=Statistic), fun.y='mean', geom="point", size=2)+
stat_summary(aes(lty=Statistic), fun.y='mean', geom="line", size=0.5)
# stat_summary(fun.data = mean_cl_normal, geom = "errorbar")
plot.3.1
n.replications <- 1e3
sd.signal <- 0.2 # keep 0 for fixed signal
epss <- c(0,0.015, 0.04)
mus <- seq(0, 2, length=10)
registerDoMC(cores=50)
results.sim <- foreach(r = seq(n.replications), .combine='rbind') %dopar% {
noise <- rmvnorm(1, mean= rep(0,p), sigma=diag(1, p))
foreach(i = seq_along(epss), .combine='rbind') %:%
foreach(j = seq_along(mus), .combine='rbind') %do% {
# i <- 2
# j <- 3
eps <- epss[i]
mu <- mus[j]
signal.counts <- rbinom(1, p, eps)
signal <- rep(0,p)
signal.locations <- sample(seq_along(signal), size = signal.counts)
x <- noise
x[signal.locations] <- rnorm(signal.counts, mu, sd.signal)
# plot(x, type='h')
data.frame(
p=p,
mu=mu,
eps=eps,
t=t_stat(x),
wilcox=wilcox_stat(x))
}
}
pbPost("note", "Done")
tail(results.sim)
alpha <- 0.05
cutoff.wilcox <- results.melt$value %>%
extract(results.melt$Statistic=='wilcox') %>%
quantile(1-alpha)
cutoff.t <- results.melt$value %>%
extract(results.melt$Statistic=='t') %>%
quantile(1-alpha)
cutoffs <- data.frame(
Statistic=c('wilcox','t'),
cutoff=c(cutoff.wilcox, cutoff.t))
results.sim.melt <- melt(results.sim, id.vars=c("p","mu","eps")) %>% tbl_df
names(results.sim.melt)[4] <- 'Statistic'
results.sim.melt.2 <- left_join(results.sim.melt, cutoffs, by='Statistic', copy=TRUE)
results.sim.melt.2 %<>%
mutate(
reject= as.numeric(value >= cutoff),
eps=round(eps,3))
plot.2.1 <- results.sim.melt.2 %>%
ggplot(aes(y=reject, x=mu, group=Statistic))
plot.3.1 <- plot.2.1 +
# facet_wrap(~eps, scales="free_y") +
facet_wrap(~eps) +
xlab('Signal')+
ylab('Power')+
# ggtitle("Fixed signal, Gaussian Noise") +
theme_bw(base_size = 20) +
stat_summary(aes(shape=Statistic), fun.y='mean', geom="point", size=2)+
stat_summary(aes(lty=Statistic), fun.y='mean', geom="line", size=0.5)
# stat_summary(fun.data = mean_cl_normal, geom = "errorbar")
plot.3.1
alpha <- 0.05/2
cutoff.wilcox <- results.melt$value %>%
extract(results.melt$Statistic=='wilcox') %>%
quantile(1-alpha)
cutoff.t <- results.melt$value %>%
extract(results.melt$Statistic=='t') %>%
quantile(1-alpha)
cutoffs <- data.frame(
Statistic=c('wilcox','t'),
cutoff=c(cutoff.wilcox, cutoff.t))
results.sim.melt <- melt(results.sim, id.vars=c("p","mu","eps")) %>% tbl_df
names(results.sim.melt)[4] <- 'Statistic'
results.sim.melt.2 <- left_join(results.sim.melt, cutoffs, by='Statistic', copy=TRUE)
results.sim.melt.2 %<>%
mutate(
reject= as.numeric(value >= cutoff),
eps=round(eps,3))
plot.2.1 <- results.sim.melt.2 %>%
ggplot(aes(y=reject, x=mu, group=Statistic))
plot.3.1 <- plot.2.1 +
# facet_wrap(~eps, scales="free_y") +
facet_wrap(~eps) +
xlab('Signal')+
ylab('Power')+
# ggtitle("Fixed signal, Gaussian Noise") +
theme_bw(base_size = 20) +
stat_summary(aes(shape=Statistic), fun.y='mean', geom="point", size=2)+
stat_summary(aes(lty=Statistic), fun.y='mean', geom="line", size=0.5)
# stat_summary(fun.data = mean_cl_normal, geom = "errorbar")
plot.3.1
pdf(file='~/workspace/WilcoxonPower/R/round_3/Figures/simualtions_paper_1_greyscale.pdf', width = 8.0, height = 6.0, onefile = FALSE, paper = "special")
plot.3.1
dev.off()
grouped <- group_by(results.sim.melt.2, list('p','eps','mu'), rejection)
names(results.sim.melt.2)
grouped <- group_by(results.sim.melt.2, list('p','eps','mu'), reject)
grouped <- group_by(results.sim.melt.2, list('p','eps','mu'))
grouped <- group_by(results.sim.melt.2, p, eps, mu)
summarise(grouped, mean=mean(value), sd=sd(value))
results.sim.melt.2
grouped <- group_by(results.sim.melt.2, eps, mu, Statistic)
summarise(grouped, mean=mean(value), sd=sd(value))
plot(summarise(grouped, mean=mean(value), sd=sd(value)))
plot(summarise(grouped, mean=mean(reject), sd=sd(reject)))
plot(summarise(grouped, mean=mean(reject)))
summarise(grouped, mean=mean(reject))
summarise(grouped, mean=mean(reject))
results.sim.summary.2 <- summarise(grouped, mean=mean(reject))
grouped.2 <- group_by(results.sim.summary.2, eps, mu)
results.sim.summary.3 <- summarise(grouped, ratio=function(x) x[1]/x[2])
summarise(grouped, ratio=function(x) x[1]/x[2])
summarise(grouped, ratio=function(x) x[[1]]/x[[2]])
summarise(grouped, ratio=function(x) identify(x))
summarise(grouped, ratio=function(x) identity(x))
summarise(grouped, ratio=function(x) x)
summarise(grouped.2, ratio=function(x) x)
summarise(grouped.2, ratio=mean)
grouped.2
summarise(grouped.2, ratio=class)
grouped.2 <- group_by(results.sim.summary.2, eps, mu)
summarise(grouped.2, ratio=length(Statistic))
summarise(grouped.2, ratio=Statistic[1]/Statistic[2])
summarise(grouped.2, ratio=Statistic[[1]]/Statistic[[2]])
summarise(grouped.2, ratio=mean)
summarise(grouped.2, ratio=mean(Statistic))
summarise(grouped.2, ratio=class(Statistic))
results.sim.summary.2
summarise(grouped.2, ratio=mean[1])
summarise(grouped.2, ratio=mean[1]/mean[2])
summarise(grouped.2, ratio=mean(mean))
grouped.2 <- group_by(results.sim.summary.2, eps, mu)
summarise(grouped.2, ratio=mean(mean))
summarise(grouped.2, ratio=prod(mean))
summarise(grouped.2, ratio=mean)
summarise(grouped.2, ratio=length(mean))
results.sim.summary.2
summarise(grouped.2, ratio=mean(mean))
summarise(grouped.2, ratio=prod(mean))
summarise(grouped.2, ratio=min(mean))
results.sim.summary.2
results.sim.summary.2 <- summarise(grouped, mean=mean())
grouped
results.sim.melt.2
names(results.sim.melt.2)
grouped <- results.sim.melt.2 %>%
select(-cutoff, -value)
grouped <- results.sim.melt.2 %>%
select(-cutoff)
results.sim.melt.2 %>%
select(-cutoff)
results.sim.melt.2 %>%
select(-cutoff, -value)
select(-cutoff, -value, -p)
results.sim.melt.2 %>%
select(-cutoff, -value, -p)
grouped <- results.sim.melt.2 %>%
select(-cutoff, -value, -p) %>%
group_by(eps, mu, Statistic)
results.sim.summary.2 <- summarise(grouped, mean=mean())
grouped <- results.sim.melt.2 %>%
select(-cutoff, -value, -p) %>%
group_by(eps, mu, Statistic)
grouped
results.sim.summary.2 <- summarise(grouped, mean=mean)
results.sim.summary.2 <- summarise(grouped, mean=mean(reject))
results.sim.summary.2
grouped
results.sim.summary.2 <- summarise(grouped, mean=mean(reject))
tail(results.sim.summary.2)
grouped.2 <- group_by(results.sim.summary.2, eps, mu)
summarise(grouped.2, ratio=min(mean))
grouped.2 <- group_by(results.sim.summary.2, eps, mu)
results.sim.summary.3 <- summarise(grouped.2, ratio=min(mean))
tail(results.sim.summary.3)
results.sim.summary.3 <- summarise(grouped.2, ratio=mean[1]/mean[2])
tail(results.sim.summary.3)
head(results.sim.summary.3)
tail(results.sim.summary.3)
results.sim.summary.3$ratio
1/results.sim.summary.3$ratio
plot(results.sim.summary.3)
results.sim.summary.3
min(results.sim.summary.3$ratio)
1/min(results.sim.summary.3$ratio)
which(min(results.sim.summary.3$ratio))
which.min(results.sim.summary.3$ratio)
results.sim.summary.3[which.min(results.sim.summary.3$ratio),]
library(ridge)
muvec <-seq(0,2,length=10) # shift size
epsvec <- c(0.015,0.040) # mixing weight
nruns <- 1e3 # number of replications
sigma <- 0.2 # variance of active group
alpha <- 0.05 # significance level
n <- 2000 #Sample size.
ct1<-matrix(0,10,2)
ct2<-matrix(0,10,2)
source('~/workspace/WilcoxonPower/Wilcoxon_power/American Statistician/Round4/code.R')
ct2<-matrix(0,10,2)
source('~/workspace/WilcoxonPower/Wilcoxon_power/American Statistician/Round4/code.R')
rnorm(1)
power1
power2
par(mfrow=c(1,2))
plot(muvec,power1[,1],type="o",ylim=c(0,1),xlab="Mu",ylab="Power")
lines(muvec,power2[,1],lty=2)
points(muvec,power2[,1])
abline(h=0.05,lty=3)
plot(muvec,power1[,2],type="o",ylim=c(0,1),xlab="Mu",ylab="Power")
lines(muvec,power2[,2],lty=2)
points(muvec,power2[,2])
abline(h=0.05,lty=3)
source('~/workspace/WilcoxonPower/Wilcoxon_power/American Statistician/Round4/code.R')
power1<-ct1/nruns
power2<-ct2/nruns
power1
par(mfrow=c(1,2))
plot(muvec,power1[,1],type="o",ylim=c(0,1),xlab="Mu",ylab="Power")
lines(muvec,power2[,1],lty=2)
points(muvec,power2[,1])
abline(h=0.05,lty=3)
plot(muvec,power1[,2],type="o",ylim=c(0,1),xlab="Mu",ylab="Power")
lines(muvec,power2[,2],lty=2)
points(muvec,power2[,2])
abline(h=0.05,lty=3)
power1[,2]/power2[,2]
plot(power1[,2]/power2[,2], type='h')
source('~/workspace/WilcoxonPower/Wilcoxon_power/American Statistician/Round4/code.R', echo=TRUE)
source('~/workspace/WilcoxonPower/Wilcoxon_power/American Statistician/Round4/code.R')
power1<-ct1/nruns # wilcoxon power
power2<-ct2/nruns # t-test power
plot(power1[,2]/power2[,2], type='h')
par(mfrow=c(1,2))
plot(muvec,power1[,1],type="o",ylim=c(0,1),xlab="Mu",ylab="Power")
lines(muvec,power2[,1],lty=2)
points(muvec,power2[,1])
abline(h=0.05,lty=3)
plot(muvec,power1[,2],type="o",ylim=c(0,1),xlab="Mu",ylab="Power")
lines(muvec,power2[,2],lty=2)
points(muvec,power2[,2])
abline(h=0.05,lty=3)
abline(h=0.05,lty=3)
abline(h=0.05,lty=3)
abline(h=0.05,lty=3)
plot(power1[,2]/power2[,2], type='h')
source('~/workspace/WilcoxonPower/Wilcoxon_power/American Statistician/Round4/code.R')
plot(power1[,2]/power2[,2], type='h')
par(mfrow=c(1,2))
plot(muvec,power1[,1],type="o",ylim=c(0,1),xlab="Mu",ylab="Power")
lines(muvec,power2[,1],lty=2)
points(muvec,power2[,1])
abline(h=0.05,lty=3)
plot(muvec,power1[,2],type="o",ylim=c(0,1),xlab="Mu",ylab="Power")
lines(muvec,power2[,2],lty=2)
points(muvec,power2[,2])
abline(h=0.05,lty=3)
plot(power1[,2]/power2[,2], type='h')
par(mfrow=c(1,1))
plot(power1[,2]/power2[,2], type='h')
source('~/workspace/WilcoxonPower/Wilcoxon_power/American Statistician/Round4/NicolesCode.R')
ct1<-matrix(0,10,2) # wilcoxon results
ct2<-matrix(0,10,2) # t-test results
for (epsind in 1:2){ # try two possible mixing weight values
eps <- epsvec[epsind]
for (run in 1:nruns){ # replicate resuls
ind <- rbinom(n,1,eps) # Which values comes from the mixture?
samp0 <- (1-ind) * rnorm(n,0,1) + ind*rnorm(n,0,sigma) # Base sample.
for (i in 1:10){ # go over mu values
samp <- samp0 + ind*muvec[i] # Adding on mu.
p1 <- wilcox.test(samp)$p.value # compute two-sided wilcoxon p-value
p2 <- t.test(samp)$p.value # compute the two-sided t-test p-value
if (p1<alpha){
# counter of number of rejections for each mu/epsilon value
ct1[i,epsind] <- ct1[i,epsind]+1
}
if (p2<alpha){
ct2[i,epsind] <- ct2[i,epsind]+1
}
}
# print(c(run,ct1))
}
}
power1<-ct1/nruns # wilcoxon power
power2<-ct2/nruns # t-test power
par(mfrow=c(1,1))
plot(power1[,2]/power2[,2], type='h')
rnorm(1e8)
power1<-ct1/nruns # wilcoxon power
muvec <-seq(0,2, length=10) # shift size
epsvec <- c(0.015, 0.04) # mixing weight
sigma <- 0.2 # variance of active group
alpha <- 0.025 # significance level
n <- 2e3 #Sample size.
nruns <- 1e3 # number of replications
# Results:
# mu values in rows and epsilon values in columns
# each entry is the number of replications rejected
ct1<-matrix(0,10,2) # wilcoxon results
ct2<-matrix(0,10,2) # t-test results
for (epsind in 1:2){ # loop over mixing weights
eps <- epsvec[epsind]
for (run in 1:nruns){ # loop over replications
ind <- rbinom(n,1,eps) # generate group indicators
samp0 <- (1-ind) * rnorm(n,0,1) + ind*rnorm(n,0,sigma) # Base sample.
for (i in 1:10){ # go over mu values
samp <- samp0 + ind*muvec[i] # Adding on mu.
p1 <- wilcox.test(samp)$p.value # compute two-sided wilcoxon p-value
p2 <- t.test(samp)$p.value # compute the two-sided t-test p-value
if (p1<alpha){
# counter of number of rejections for each mu/epsilon value
ct1[i,epsind] <- ct1[i,epsind]+1
}
if (p2<alpha){
ct2[i,epsind] <- ct2[i,epsind]+1
}
}
# print(c(run,ct1))
}
}
plot(power1[,2]/power2[,2], type='h')
power1<-ct1/nruns # wilcoxon power
power2<-ct2/nruns # t-test power
plot(power1[,2]/power2[,2], type='h')
cutoffs
cutoffs
load(file='~/workspace/WilcoxonPower/R/round_3/Rdata/cutoffs_for_paper.RData')
cutoffs
cutoffs
pnorm(cutoffs$cutoff[2])
pnorm(-cutoffs$cutoff[2])
pnorm(-cutoffs$cutoff[2])*2
ct3<-matrix(0,10,2) # wilcoxon statistic results
ct4<-matrix(0,10,2) # t-test statistic results
wilcox.test(samp)
wilcox.result <- wilcox.test(samp)
wilcox.result <- wilcox.test(samp)
p1 <- wilcox.result$p.value # compute two-sided wilcoxon p-value
ttest.result <- t.test(samp)
p2 <- ttest.result$p.value # compute the two-sided t-test p-value
p3 <- wilcox.result$statistic # compute two-sided wilcoxon p-value
p4 <- ttest.result$statistic # compute the two-sided t-test p-value
cutoffs$cutoff
cutoff.wilcox <- cutoffs$Statistic
cutoffs$Statistic
cutoff.wilcox <- cutoffs$cutoff[1]
cutoff.wilcox
cutoff.ttest <- cutoffs$cutoff[2]
cutoff.wilcox
cutoff.ttest
muvec <-seq(0,2, length=10) # shift size
epsvec <- c(0.015, 0.04) # mixing weight
sigma <- 0.2 # variance of active group
alpha <- 0.025 # significance level
n <- 2e3 #Sample size.
nruns <- 1e3 # number of replications
ct1<-matrix(0,10,2) # wilcoxon pvalue results
ct2<-matrix(0,10,2) # t-test pvalue results
ct3<-matrix(0,10,2) # wilcoxon statistic results
ct4<-matrix(0,10,2) # t-test statistic results
cutoff.wilcox <- cutoffs$cutoff[1]
cutoff.ttest <- cutoffs$cutoff[2]
load(file='~/workspace/WilcoxonPower/R/round_3/Rdata/cutoffs_for_paper.RData')
cutoff.wilcox <- cutoffs$cutoff[1]
cutoff.ttest <- cutoffs$cutoff[2]
for (epsind in 1:2){ # loop over mixing weights
eps <- epsvec[epsind]
for (run in 1:nruns){ # loop over replications
ind <- rbinom(n,1,eps) # generate group indicators
samp0 <- (1-ind) * rnorm(n,0,1) + ind*rnorm(n,0,sigma) # Base sample.
for (i in 1:10){ # go over mu values
samp <- samp0 + ind*muvec[i] # Adding on mu.
wilcox.result <- wilcox.test(samp)
ttest.result <- t.test(samp)
p1 <- wilcox.result$p.value # compute two-sided wilcoxon p-value
p2 <- ttest.result$p.value # compute the two-sided t-test p-value
p3 <- wilcox.result$statistic # compute two-sided wilcoxon p-value
p4 <- ttest.result$statistic # compute the two-sided t-test p-value
# counter of number of rejections for each mu/epsilon value
if (p1 < alpha) ct1[i,epsind] <- ct1[i,epsind]+1
if (p2 < alpha) ct2[i,epsind] <- ct2[i,epsind]+1
if (p3 < cutoff.wilcox) ct3[i,epsind] <- ct3[i,epsind]+1
if (p4 < cutoff.ttest) ct4[i,epsind] <- ct4[i,epsind]+1
}
}
for (epsind in 1:2){ # loop over mixing weights
eps <- epsvec[epsind]
for (run in 1:nruns){ # loop over replications
ind <- rbinom(n,1,eps) # generate group indicators
samp0 <- (1-ind) * rnorm(n,0,1) + ind*rnorm(n,0,sigma) # Base sample.
for (i in 1:10){ # go over mu values
samp <- samp0 + ind*muvec[i] # Adding on mu.
wilcox.result <- wilcox.test(samp)
ttest.result <- t.test(samp)
p1 <- wilcox.result$p.value # compute two-sided wilcoxon p-value
p2 <- ttest.result$p.value # compute the two-sided t-test p-value
p3 <- wilcox.result$statistic # compute two-sided wilcoxon p-value
p4 <- ttest.result$statistic # compute the two-sided t-test p-value
# counter of number of rejections for each mu/epsilon value
if (p1 < alpha) ct1[i,epsind] <- ct1[i,epsind]+1
if (p2 < alpha) ct2[i,epsind] <- ct2[i,epsind]+1
if (p3 < cutoff.wilcox) ct3[i,epsind] <- ct3[i,epsind]+1
if (p4 < cutoff.ttest) ct4[i,epsind] <- ct4[i,epsind]+1
}
}
}
for (epsind in 1:2){ # loop over mixing weights
eps <- epsvec[epsind]
for (run in 1:nruns){ # loop over replications
ind <- rbinom(n,1,eps) # generate group indicators
samp0 <- (1-ind) * rnorm(n,0,1) + ind*rnorm(n,0,sigma) # Base sample.
for (i in 1:10){ # go over mu values
samp <- samp0 + ind*muvec[i] # Adding on mu.
wilcox.result <- wilcox.test(samp)
ttest.result <- t.test(samp)
p1 <- wilcox.result$p.value # compute two-sided wilcoxon p-value
p2 <- ttest.result$p.value # compute the two-sided t-test p-value
p3 <- wilcox.result$statistic # compute two-sided wilcoxon p-value
p4 <- ttest.result$statistic # compute the two-sided t-test p-value
# counter of number of rejections for each mu/epsilon value
if (p1 < alpha) ct1[i,epsind] <- ct1[i,epsind]+1
if (p2 < alpha) ct2[i,epsind] <- ct2[i,epsind]+1
if (p3 < cutoff.wilcox) ct3[i,epsind] <- ct3[i,epsind]+1
if (p4 < cutoff.ttest) ct4[i,epsind] <- ct4[i,epsind]+1
}
}
}
power1<-ct1/nruns # wilcoxon power
power2<-ct2/nruns # t-test power
power3<-ct3/nruns # wilcoxon power
power4<-ct4/nruns # t-test power
plot(power1[,2]/power2[,2], type='h') # using theoretical cutoff
plot(power3[,2]/power4[,2], type='h') # using simulated cutoff
power1<-ct1/nruns # wilcoxon power
power2<-ct2/nruns # t-test power
power3<-ct3/nruns # wilcoxon power
power4<-ct4/nruns # t-test power
plot(power1[,2]/power2[,2], type='h') # using theoretical cutoff
plot(power3[,2]/power4[,2], type='h') # using simulated cutoff
power3<-1-ct3/nruns # wilcoxon power
power4<-1-ct4/nruns # t-test power
plot(power3[,2]/power4[,2], type='h') # using simulated cutoff
install.packages('odbc')
install.packages('odbc')
install.packages('odbc')
install.packages('Rcpp')
odbc::odbcListDrivers()
registerDoMC(cores=40)
source('Gilron Effect of Cross Validatino.R')
balance <- FALSE   # set for TRUE for balanced folding ana refolding.
balance.log <- 'balance_log.txt'
file.remove(balance.log)
file.create(balance.log)
n.replications <- 4e1 #4e3
p <- 23
n <- 4e1 # total sample size-> n/2 in each group.
n.permutations <- 3e2
n.folds <- 4
cost.1 <- 1e1
cost.2 <- 1e-1
effects <- sqrt(40/400) * seq(0, 0.5, length=3) # change in locatinon
# effects <- seq(1, 1.2, length=3) # change in scale
# RNGkind("Wich") # Set random number generator.
RNGkind("default")
Sigma <- diag(p)
# Sigma <- ar1_cov(p, rho=0.8)
# Sigma <- comSym_cov(p, rho=0.7)
# Sigma <- diag((1:p)*p/sum(1:p))
file.name <- "file2"
the.message <- paste(file.name)
# Or
export OPENBLAS_NUM_THREADS=x
registerDoMC(cores=40)
foreach(i=1:60) %dopar% {
eigen(matrix(rnorm(1e6), ncol = 1e3, nrow = 1e3))
}
registerDoMC(cores=40)
sessionInfo()
